<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Convenience to define functions which produce new strategies."><meta name="keywords" content="rust, rustlang, rust-lang, prop_compose"><title>prop_compose in proptest::prelude - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../proptest/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../proptest/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In proptest::prelude</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Macro <a href="../index.html">proptest</a>::<wbr><a href="index.html">prelude</a>::<wbr><a class="macro" href="#">prop_compose</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/proptest/sugar.rs.html#607-685">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-decl"><div class="example-wrap"><pre class="rust macro"><code><span class="macro">macro_rules! </span>prop_compose {
    ($(<span class="attribute">#[<span class="macro-nonterminal">$meta</span>:meta]</span>)*
     <span class="macro-nonterminal">$vis</span>:vis
     $([$(<span class="macro-nonterminal">$modi</span>:tt)<span class="kw-2">*</span>])<span class="question-mark">? </span><span class="kw">fn </span><span class="macro-nonterminal">$name</span>:ident <span class="macro-nonterminal">$params</span>:tt
     ($(<span class="macro-nonterminal">$var</span>:pat <span class="kw">in </span><span class="macro-nonterminal">$strategy</span>:expr),+ $(,)<span class="question-mark">?</span>)
       -&gt; <span class="macro-nonterminal">$return_type</span>:ty <span class="macro-nonterminal">$body</span>:block) =&gt; { ... };
    ($(<span class="attribute">#[<span class="macro-nonterminal">$meta</span>:meta]</span>)*
     <span class="macro-nonterminal">$vis</span>:vis
     $([$(<span class="macro-nonterminal">$modi</span>:tt)<span class="kw-2">*</span>])<span class="question-mark">? </span><span class="kw">fn </span><span class="macro-nonterminal">$name</span>:ident <span class="macro-nonterminal">$params</span>:tt
     ($(<span class="macro-nonterminal">$var</span>:pat <span class="kw">in </span><span class="macro-nonterminal">$strategy</span>:expr),+ $(,)<span class="question-mark">?</span>)
     ($(<span class="macro-nonterminal">$var2</span>:pat <span class="kw">in </span><span class="macro-nonterminal">$strategy2</span>:expr),+ $(,)<span class="question-mark">?</span>)
       -&gt; <span class="macro-nonterminal">$return_type</span>:ty <span class="macro-nonterminal">$body</span>:block) =&gt; { ... };
    ($(<span class="attribute">#[<span class="macro-nonterminal">$meta</span>:meta]</span>)*
     <span class="macro-nonterminal">$vis</span>:vis
     $([$(<span class="macro-nonterminal">$modi</span>:tt)<span class="kw-2">*</span>])<span class="question-mark">? </span><span class="kw">fn </span><span class="macro-nonterminal">$name</span>:ident <span class="macro-nonterminal">$params</span>:tt
     ($(<span class="macro-nonterminal">$arg</span>:tt)+)
       -&gt; <span class="macro-nonterminal">$return_type</span>:ty <span class="macro-nonterminal">$body</span>:block) =&gt; { ... };
    ($(<span class="attribute">#[<span class="macro-nonterminal">$meta</span>:meta]</span>)*
     <span class="macro-nonterminal">$vis</span>:vis
     $([$(<span class="macro-nonterminal">$modi</span>:tt)<span class="kw-2">*</span>])<span class="question-mark">? </span><span class="kw">fn </span><span class="macro-nonterminal">$name</span>:ident <span class="macro-nonterminal">$params</span>:tt
     ($(<span class="macro-nonterminal">$arg</span>:tt)+ $(,)<span class="question-mark">?</span>)
     ($(<span class="macro-nonterminal">$arg2</span>:tt)+ $(,)<span class="question-mark">?</span>)
       -&gt; <span class="macro-nonterminal">$return_type</span>:ty <span class="macro-nonterminal">$body</span>:block) =&gt; { ... };
}</code></pre></div>
</div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Convenience to define functions which produce new strategies.</p>
<p>The macro has two general forms. In the first, you define a function with
two argument lists. The first argument list uses the usual syntax and
becomes exactly the argument list of the defined function. The second
argument list uses the <code>in strategy</code> syntax as with <code>proptest!</code>, and is
used to generate the other inputs for the function. The second argument
list has access to all arguments in the first. The return type indicates
the type of value being generated; the final return type of the function is
<code>impl Strategy&lt;Value = $type&gt;</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proptest::prelude::<span class="kw-2">*</span>;

<span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">struct </span>MyStruct {
  integer: u32,
  string: String,
}

<span class="macro">prop_compose! </span>{
  <span class="kw">fn </span>my_struct_strategy(max_integer: u32)
                       (integer <span class="kw">in </span><span class="number">0</span>..max_integer, string <span class="kw">in </span><span class="string">&quot;.*&quot;</span>)
                       -&gt; MyStruct {
    MyStruct { integer, string }
  }
}</code></pre></div>
<p>This form is simply sugar around making a tuple and then calling <code>prop_map</code>
on it. You can also use <code>arg: type</code> as in <code>proptest! { .. }</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="macro">prop_compose! </span>{
  <span class="kw">fn </span>my_struct_strategy(max_integer: u32)
                       (integer <span class="kw">in </span><span class="number">0</span>..max_integer, string: String)
                       -&gt; MyStruct {
    MyStruct { integer, string }
  }
}</code></pre></div>
<p>The second form is mostly the same, except that it takes <em>three</em> argument
lists. The third argument list can see all values in both prior, which
permits producing strategies based on other strategies.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proptest::prelude::<span class="kw-2">*</span>;

<span class="macro">prop_compose! </span>{
  <span class="kw">fn </span>nearby_numbers()(centre <span class="kw">in </span>-<span class="number">1000</span>..<span class="number">1000</span>)
                   (a <span class="kw">in </span>centre-<span class="number">10</span>..centre+<span class="number">10</span>,
                    b <span class="kw">in </span>centre-<span class="number">10</span>..centre+<span class="number">10</span>)
                   -&gt; (i32, i32) {
    (a, b)
  }
}</code></pre></div>
<p>However, the body of the function does <em>not</em> have access to the second
argument list. If the body needs access to those values, they must be
passed through explicitly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proptest::prelude::<span class="kw-2">*</span>;

<span class="macro">prop_compose! </span>{
  <span class="kw">fn </span>vec_and_index
    (max_length: usize)
    (vec <span class="kw">in </span>prop::collection::vec(<span class="number">1</span>..<span class="number">10</span>, <span class="number">1</span>..max_length))
    (index <span class="kw">in </span><span class="number">0</span>..vec.len(), vec <span class="kw">in </span>Just(vec))
    -&gt; (Vec&lt;i32&gt;, usize)
  {
    (vec, index)
  }
}</code></pre></div>
<p>The second form is sugar around making a strategy tuple, calling
<code>prop_flat_map()</code>, then <code>prop_map()</code>.</p>
<p>To give the function any modifier which isn’t a visibility modifier, put it
in brackets before the <code>fn</code> token but after any visibility modifier.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proptest::prelude::<span class="kw-2">*</span>;

<span class="macro">prop_compose! </span>{
  <span class="kw">pub</span>(<span class="kw">crate</span>) [<span class="kw">unsafe</span>] <span class="kw">fn </span>pointer()(v <span class="kw">in </span>prop::num::usize::ANY)
                                -&gt; <span class="kw-2">*const </span>() {
    v <span class="kw">as </span><span class="kw-2">*const </span>()
  }
}</code></pre></div>
<h3 id="comparison-with-hypothesis-composite"><a href="#comparison-with-hypothesis-composite">Comparison with Hypothesis’ <code>@composite</code></a></h3>
<p><code>prop_compose!</code> makes it easy to do a lot of things you can do with
<a href="https://hypothesis.readthedocs.io/en/latest/data.html#composite-strategies">Hypothesis’ <code>@composite</code></a>,
but not everything.</p>
<ul>
<li>
<p>You can’t filter via this macro. For filtering, you need to make the
strategy the “normal” way and use <code>prop_filter()</code>.</p>
</li>
<li>
<p>More than two layers of strategies or arbitrary logic between the two
layers. If you need either of these, you can achieve them by calling
<code>prop_flat_map()</code> by hand.</p>
</li>
</ul>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="proptest" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>